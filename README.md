# lv_cxx_bindgen
A C++ binding generator for LVGL. Written in Rust (oh the irony)

> This is still work-in-progress, it doesn't even generate any sources for
> now, but it's in the works.

This generator uses the LVGL JSON API map, that will later be analyzed, and used as a basis for all
autogenerated C++ code. Also, it supports different C++ target versions, from C++11 to C++23. 

## Usage

`lv_cxx_bindgen` requires a config file, by default named `lv_cxx_bindgen.toml` and
looked for in CWD, but can be specified in the `-c` argument.

> TODO: Finish writing this section after CLI API is finished

## Configuration

All configuration is done in the `lv_cxx_bindgen.toml` file. An example file
looks like this:

```toml
[input]
cwd = "thirdparty/lvgl"

[generation]
target = "c++20"
class = {
    exclude = {
        groups = ["anim"],
        functions = ["obj_get_disp", "font_set_kerning"]
    }
    renames = [
        ["obj", "Object"]
    ]
}
namespace = {
    exclude = ["obj"],
    renames = [
        ["anim", "animation"]
    ]
}
```

### Input

- `cwd` - current working directory. Used when resolving input file paths.

- `files` - input files, which are then parsed for functions. If `auto_scan` is enabled,
it will also scan the input files for #include directives, and adds those files to the list
of input files.

### Generation

- `target` - target C++ version, by default C++20. All the differences between different
targets and generated output:

- C++11
    - Functions that accept arrays in arguments have those arguments converted from pointers
    to `std::vector` or `std::array`, depending on configuration
    - Functions that accept function pointers in arguments have those arguments converted
    to `std::function`, but as an overload, so there are options for `std::function`, and
    normal function pointers
- C++14 & C++17 don't have any changes, but it's still a good idea to set the target to your
C++ version, so that in future updates it will not break
- C++20
    - Now there is no header file in the output, only a `.cppm` file, which is a C++ module,
    that can be imported with `import lvgl;`
- C++23
    - Instead of `std::optional` or sometimes `bool` return values that specify that an error
    happened, `std::expected` is used.

> TODO: document `classes` and `namespaces` when those will be implemented

- `class.exclude` - function groups that are excluded from assigning to a class.
For example, if you specify `"obj"` in the list, any function that starts with `lv_obj_` will not
get assigned to any class
- `class.renames` - 

## Process

In short, the whole process can be simplified to 3 main steps:

- Parsing
- Grouping
- Generation

The first step is the simplest one, it just parses a JSON API map file, extracts
all relevant data, and does some simplification/processing on that data.

The second step then groups all items inside that list in, well, groups, for
example "this group of functions should result in a class", or "this group
of functions should result in a namespace" etc.

And the best for last, the third step consists of actually converting allat into
actual C++ code. That shit is done manually, for plain efficiency and also ease
of understanding what is actually going on. Also, an additional `clang-format`
run can be named a "three and a half" step, because it's part of codegen, but not
part of the actual generator.

So, a full process can be described like this:

- Extraction
    - Parsing of `lvgl.json` (a.k.a. LVGL API Map)
    - Function list extraction
    - Function list simplification (removal of singular void args, etc)
- Grouping
    - In namespaces
    - In classes
    - Function arguments transformation for more idiomatic C++
- Generation
    - Conversion of groups into output AST
    - AST to source code generation
    - clang-format run over generated code

## FAQ

### Q: Are exceptions used in any shape or form?

A: No, never. That's the worst idea known to man, especially knowing that
LVGL is supposed to run on embedded systems. Exceptions introduce a lot of
overhead, and are generally a pain in the ass. As a replacement, `lvgl::optional`,
`std::optional`, `bool`, `lvgl::expected`, and `std::expected` types are used,
depending on context. 

> Note: `std::expected` is used when target is C++23, and `std::optional` with C++17.
> If the target is lower than required, a substitute type from the `lvgl` namespace
> is used as a replacement.

